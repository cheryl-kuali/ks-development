<beans
        xmlns="http://www.springframework.org/schema/beans"
        xmlns:amq="http://activemq.apache.org/schema/core"
        xmlns:jms="http://www.springframework.org/schema/jms"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xmlns:aop="http://www.springframework.org/schema/aop"
        xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd
            http://activemq.apache.org/schema/core http://activemq.apache.org/schema/core/activemq-core.xsd
            http://www.springframework.org/schema/jms http://www.springframework.org/schema/jms/spring-jms-2.5.xsd
            http://camel.apache.org/schema/spring http://camel.apache.org/schema/spring/camel-spring.xsd
            http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd">


    <!-- Basic AMQ connection factory -->
    <!-- <amq:connectionFactory id="amqConnectionFactory" brokerURL="vm://localhost" /> -->
    <!-- In many cases the ActiveMQ broker will be embedded. If this is the case, connect via the vm transport. If you
         can't connect via the vm transport, use the configured connection url -->
    <amq:connectionFactory id="amqConnectionFactory" brokerURL="${ks.mqlistener.url}" />

    <!-- Wraps the AMQ connection factory in Spring's caching (ie: pooled) factory
         From the AMQ "Spring Support"-page: "You can use the PooledConnectionFactory for efficient pooling... or you
         can use the Spring JMS CachingConnectionFactory to achieve the same effect."
         See "Consuming JMS from inside Spring" at http://activemq.apache.org/spring-support.html
         Also see http://codedependents.com/2010/07/14/connectionfactories-and-caching-with-spring-and-activemq/

         Note: there are pros/cons to using Spring's caching factory vs Apache's PooledConnectionFactory; but, until
         we have more explicit reasons to favor one over the other, Spring's is less tightly-coupled to a specific
         AMQP-implementation.
         See http://stackoverflow.com/a/19594974
    -->
    <bean id="connectionFactory" class="org.springframework.jms.connection.CachingConnectionFactory">
        <constructor-arg ref="amqConnectionFactory"/>
        <property name="sessionCacheSize" value="1"/>
    </bean>

    <bean id="jmsTemplate" class="org.springframework.jms.core.JmsTemplate">
        <constructor-arg ref="connectionFactory" />
    </bean>

    <bean id="jmsTopicTemplate" class="org.springframework.jms.core.JmsTemplate">
        <constructor-arg ref="connectionFactory" />
        <property name="pubSubDomain" value="true"/>
    </bean>

    <bean id="jmsConfig"
          class="org.apache.camel.component.jms.JmsConfiguration">
        <property name="connectionFactory" ref="connectionFactory"/>
        <property name="concurrentConsumers" value="1"/>
    </bean>

    <!-- The ActiveMQ camel component allows messages to be sent to a JMS Queue or Topic or messages to be consumed from a JMS Queue or Topic using Apache ActiveMQ -->
    <bean id="activemq"
          class="org.apache.activemq.camel.component.ActiveMQComponent">
        <property name="configuration" ref="jmsConfig"/>
    </bean>

    <jms:listener-container concurrency="1" >
        <!-- This is used for performance monitoring of queues -->
        <jms:listener id="regPerfListener" destination="org.kuali.student.enrollment.registration.performanceStatsQueue" ref="performanceStatsListener" />
    </jms:listener-container>

    <!--Used to collect performance statistics -->
    <bean id="performanceStatsListener" class="org.kuali.student.enrollment.registration.engine.listener.SimplePerformanceListener">
        <property name="jmsTemplate" ref="jmsTemplate"/>
    </bean>

    <!-- Starts the registration process for adds/drops/updates/swaps/etc. -->
    <bean id="registrationInitializationProcessor" class="org.kuali.student.enrollment.registration.engine.processor.CourseRegistrationInitializationProcessor">
        <property name="courseRegistrationEngineService" ref="courseRegistrationEngineService"/>
    </bean>

    <!-- Verifies the reg request -->
    <bean id="registrationVerificationProcessor" class="org.kuali.student.enrollment.registration.engine.processor.CourseRegistrationVerifyRegRequestProcessor">
        <property name="courseRegistrationErrorProcessor" ref="courseRegistrationErrorProcessor"/>
    </bean>

    <!-- Processes the waitlist when seats open up -->
    <bean id="waitlistManagerProcessor" class="org.kuali.student.enrollment.registration.engine.processor.CourseRegistrationWaitlistManagerProcessor">
        <property name="waitlistManagerService" ref="waitlistManagerService"/>
    </bean>

    <camelContext xmlns="http://camel.apache.org/schema/spring">

        <!--
        Any uncaught exceptions will go through the error processor, which
        will set the state of the error item(s) as "failed". The transaction
        will be marked as "handled".
        -->
        <onException>
            <exception>java.lang.Exception</exception>
            <handled><constant>true</constant></handled>
            <bean ref="courseRegistrationErrorProcessor" method="process" />
        </onException>

        <route>
            <from uri="activemq:org.kuali.student.enrollment.registration.seatOpenEventQueue"/>
            <bean ref="waitlistManagerProcessor" method="process"/>
        </route>

        <route> <!-- This route sets the status of the transaction to processing.  -->
            <from uri="activemq:org.kuali.student.enrollment.registration.initializationListenerQueue"/>
            <bean ref="regEnginePerfPojo" method="notifyPerfStart(${body['regReqId']})" />
            <bean ref="registrationInitializationProcessor" method="process"/> <!-- go to the java code that makes all the decisions -->
            <to uri="activemq:org.kuali.student.enrollment.registration.verificationQueue"/>
        </route>

        <route> <!-- This route validates the request.  -->
            <from uri="activemq:org.kuali.student.enrollment.registration.verificationQueue"/>
            <bean ref="registrationVerificationProcessor" method="process"/> <!-- go to the java code that makes all the decisions -->
            <to uri="activemq:org.kuali.student.enrollment.registration.splitByItemQueue"/>
        </route>

        <route> <!-- This route splits the reg request into it's items. Adding needed info to the message header.  -->
            <from uri="activemq:org.kuali.student.enrollment.registration.splitByItemQueue" />  <!-- pick up the reg req -->
            <setHeader headerName="regReqId"> <!-- Need to store the Reg Req in the header  -->
                <simple>${body.registrationRequest.id}</simple>
            </setHeader>
            <setHeader headerName="regReqItemCount"> <!-- In order to join back later we need to know the req item count -->
                <simple>${body.registrationRequest.registrationRequestItems.size}</simple>
            </setHeader>
            <split parallelProcessing="false"> <!-- Split the RegRequestInfo into it's individual requestItems (add, drop, etc) -->
                <method ref="requestSplitter"  method="split" />   <!-- does the actual splitting -->
                <setHeader headerName="JMSXGroupID"> <!-- This is CRITICAL. It is how we ensure valid seat check counts without db locking -->
                    <simple>FOID=${body.registrationGroup.formatOfferingId}</simple>  <!-- grouping on the foid -->
                </setHeader>
                <to uri="activemq:org.kuali.student.enrollment.registration.lprActionQueue"/> <!-- send to queue's for processing-->
            </split>
        </route>

        <route>    <!-- performs the update/drop/(waitlist check + seat check + add) -->
            <from uri="activemq:org.kuali.student.enrollment.registration.lprActionQueue" />
            <onException>
                <exception>java.lang.Exception</exception>
                <handled><constant>true</constant></handled>
                <bean ref="courseRegistrationErrorProcessor" method="process" />
                <to uri="activemq:org.kuali.student.enrollment.registration.regReqItemJoinQueue"/> <!-- attempt to rejoin the queue -->
            </onException>
            <bean ref="courseRegistrationLprActionProcessor" method="process"/> <!-- go to the java code that makes all the decisions -->
            <to uri="activemq:org.kuali.student.enrollment.registration.regReqItemJoinQueue"/> <!-- send to join queue's for final processing-->
        </route>

        <route>    <!-- This route joins items from the reg req item split. Once all items have completed, update lprTrans state-->
            <from uri="activemq:org.kuali.student.enrollment.registration.regReqItemJoinQueue?concurrentConsumers=1" />  <!-- Every Reg Req Item will come here-->
            <aggregate strategyRef="simpleAggregator" ignoreInvalidCorrelationKeys="false"> <!-- take all the Reg Req Items an join them to their req -->
                <correlationExpression>
                    <header>regReqId</header> <!-- correlate on the regReqId we stored in the header -->
                </correlationExpression>
                <completionSize>
                    <header>regReqItemCount</header> <!-- stop aggregating when we've reached the reg req item count size-->
                </completionSize>
                <bean ref="courseRegistrationLprActionProcessor" method="updateRegistrationRequestStatus"/> <!-- update lprTrans status -->
                <bean ref="regEnginePerfPojo" method="notifyPerfEnd(${header.regReqId})" /> <!-- notify perf listener that we're done -->
            </aggregate>
        </route>

        <route>    <!-- performs the update/drop/(waitlist check + seat check + add) -->
            <from uri="activemq:topic:org.kuali.student.enrollment.lui.service.LuiEventTopic?concurrentConsumers=1" />
            <filter>
                <simple>${in.body.type} contains 'kuali.lui.type.activity.offering' and ${in.body.action} == 'UPDATE'</simple>
                <aggregate strategyRef="useLatestAggregationStrategy" completionTimeout="5000">
                    <correlationExpression>
                        <simple>body.id</simple>
                    </correlationExpression>
                    <bean ref="waitlistManagerService" method="processLuiChangeEvent"/> <!-- go to the java code that makes all the decisions -->
                </aggregate>
            </filter>

        </route>

        <route>    <!-- This is used to detect changes course offerings and notify our UI caches -->
            <from uri="activemq:topic:org.kuali.student.enrollment.lui.service.LuiEventTopic?concurrentConsumers=1" />
            <filter>
                <simple>${in.body.type} contains 'kuali.lui.type.course.offering'</simple>
                <filter>
                    <simple>${in.body.action} == 'UPDATE' or ${in.body.action} == 'CREATE'</simple>
                    <aggregate strategyRef="useLatestAggregationStrategy" completionTimeout="5000">
                        <correlationExpression>
                            <simple>body.id</simple>
                        </correlationExpression>
                        <to uri="activemq:org.kuali.student.enrollment.registration.elastic.courseoffering.updateQueue"/>
                    </aggregate>
                </filter>
            </filter>
            <filter>
                <simple>${in.body.type} contains 'kuali.lui.type.registration.group'</simple>
                <filter>
                    <simple>${in.body.action} == 'UPDATE' or ${in.body.action} == 'CREATE'</simple>
                    <aggregate strategyRef="useLatestAggregationStrategy" completionTimeout="5000">
                        <correlationExpression>
                            <simple>body.id</simple>
                        </correlationExpression>
                        <to uri="activemq:org.kuali.student.enrollment.registration.elastic.registrationgroup.updateQueue"/>
                    </aggregate>
                </filter>
            </filter>
        </route>
        <route>    <!-- This is used to detect changes in registration groups and notify our UI reg group caches -->
            <from uri="activemq:topic:org.kuali.student.enrollment.lui.service.LuiEventTopic?concurrentConsumers=1" />
            <filter>
                <simple>${in.body.type} contains 'kuali.lui.type.registration.group'</simple>
                <filter>
                    <simple>${in.body.action} == 'UPDATE' or ${in.body.action} == 'CREATE'</simple>
                    <aggregate strategyRef="useLatestAggregationStrategy" completionTimeout="5000">
                        <correlationExpression>
                            <simple>body.id</simple>
                        </correlationExpression>
                        <to uri="activemq:org.kuali.student.enrollment.registration.elastic.registrationgroup.updateQueue"/>
                    </aggregate>
                </filter>
            </filter>
        </route>
        <route>    <!-- This is used to detect changes in registration and notify our UI reg group caches -->
            <from uri="activemq:topic:org.kuali.student.enrollment.class2.courseoffering.service.CourseOfferingEventTopic?concurrentConsumers=1" />
            <filter>
                <simple>${in.body.type} contains 'kuali.lui.type.registration.group'</simple>
                <filter>
                    <simple>${in.body.action} == 'DELETE'</simple>
                    <aggregate strategyRef="useLatestAggregationStrategy" completionTimeout="5000">
                        <correlationExpression>
                            <simple>body.id</simple>
                        </correlationExpression>
                        <to uri="activemq:org.kuali.student.enrollment.registration.elastic.registrationgroup.updateQueue"/>
                    </aggregate>
                </filter>
            </filter>
        </route>

    </camelContext>

    <bean id="useLatestAggregationStrategy" class="org.apache.camel.processor.aggregate.UseLatestAggregationStrategy"/>

    <bean id="requestSplitter" class="org.kuali.student.enrollment.registration.engine.camel.splitter.RegistrationRequestSplitter"/>  <!-- pull reg info from db. transform into useful objects -->
    <bean id="simpleAggregator" class="org.kuali.student.enrollment.registration.engine.camel.aggregator.SimpleAggregator"/>  <!-- very simple aggregator that takes the ao results and combines them into a list. Should return a more complex object in future -->
    <bean id="eventMessageIdAggregator" class="org.kuali.student.enrollment.registration.engine.camel.aggregator.EventMessageIdAggregator"/>  <!-- EventMessage ID aggregator. Returns a list of EventMessage Ids -->
    <bean id="regEnginePerfPojo" class="org.kuali.student.enrollment.registration.engine.processor.RegEnginePerformanceProcessor">  <!-- very simple aggregator that takes the ao results and combines them into a list. Should return a more complex object in future -->
        <property name="jmsTemplate" ref="jmsTemplate"/>
    </bean>
    <bean id="courseRegistrationLprActionProcessor" class="org.kuali.student.enrollment.registration.engine.processor.CourseRegistrationLprActionProcessor">
        <property name="courseRegistrationEngineService" ref="courseRegistrationEngineService"/>
        <property name="jmsTemplate" ref="jmsTemplate"/>
    </bean>

    <bean id="courseRegistrationErrorProcessor" class="org.kuali.student.enrollment.registration.engine.processor.CourseRegistrationErrorProcessor">
        <property name="courseRegistrationEngineService" ref="courseRegistrationEngineService"/>
    </bean>

    <bean id="waitlistManagerService" class="org.kuali.student.enrollment.registration.engine.service.impl.WaitlistManagerServiceImpl">
        <property name="jmsTemplate" ref="jmsTemplate"/>
    </bean>




    <!-- Groups common registration functions into a single service -->
    <bean id="courseRegistrationEngineService" class="org.kuali.student.enrollment.registration.engine.service.impl.CourseRegistrationEngineServiceImpl">
        <property name="waitlistManagerService" ref="waitlistManagerService"/>
    </bean>


    <!-- AOP of LUI Service. Needed for Eventing -->
    <bean id="luiBroadcastAspect" class="org.kuali.student.enrollment.class1.lui.aop.LuiBroadcastAspect">
        <property name="jmsTemplate" ref="jmsTopicTemplate"/> <!-- send messages to the topic, not queue -->
        <property name="jmsDestination" value="org.kuali.student.enrollment.lui.service.LuiEventTopic"/>
    </bean>
    <bean id="courseOfferingBroadcastAspect" class="org.kuali.student.enrollment.class2.courseoffering.aop.CourseOfferingBroadcastAspect">
        <property name="jmsTemplate" ref="jmsTopicTemplate"/> <!-- send messages to the topic, not queue -->
        <property name="jmsDestination" value="org.kuali.student.enrollment.class2.courseoffering.service.CourseOfferingEventTopic"/>
    </bean>


    <aop:config proxy-target-class="false">
        <aop:aspect ref="luiBroadcastAspect">
            <aop:pointcut id="luiUpdate" expression="execution(* org.kuali.student.enrollment.class1.lui.service.impl.LuiServiceImpl.updateLui(..))" />
            <aop:after-returning pointcut-ref="luiUpdate" method="updateLuiAdvise" returning="retVal"  />
        </aop:aspect>
        <aop:aspect ref="luiBroadcastAspect">
            <aop:pointcut id="luiCreate" expression="execution(* org.kuali.student.enrollment.class1.lui.service.impl.LuiServiceImpl.createLui(..))" />
            <aop:after-returning pointcut-ref="luiCreate" method="createLuiAdvise" returning="retVal" />
        </aop:aspect>
        <aop:aspect ref="courseOfferingBroadcastAspect">
            <aop:pointcut id="registrationGroupDelete" expression="execution(* org.kuali.student.enrollment.class2.courseoffering.service.impl.CourseOfferingServiceImpl.deleteRegistrationGroup(..))" />
            <aop:after-returning pointcut-ref="registrationGroupDelete" method="deleteRegistrationGroupAdvise" />
        </aop:aspect>


    </aop:config>





</beans>
